//go:build !ignore_autogenerated

/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestKind) DeepCopyInto(out *TestKind) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	out.Status = in.Status
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestKind.
func (in *TestKind) DeepCopy() *TestKind {
	if in == nil {
		return nil
	}
	out := new(TestKind)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TestKind) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestKindList) DeepCopyInto(out *TestKindList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]TestKind, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestKindList.
func (in *TestKindList) DeepCopy() *TestKindList {
	if in == nil {
		return nil
	}
	out := new(TestKindList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TestKindList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestKindSpec) DeepCopyInto(out *TestKindSpec) {
	*out = *in
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(int32)
		**out = **in
	}
	if in.TestMap2 != nil {
		in, out := &in.TestMap2, &out.TestMap2
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.UnholyAbomination != nil {
		in, out := &in.UnholyAbomination, &out.UnholyAbomination
		*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
		for key, val := range *in {
			var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
				for key, val := range *in {
					var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
						for key, val := range *in {
							var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
							if val == nil {
								(*out)[key] = nil
							} else {
								inVal := (*in)[key]
								in, out := &inVal, &outVal
								*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
								for key, val := range *in {
									var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
									if val == nil {
										(*out)[key] = nil
									} else {
										inVal := (*in)[key]
										in, out := &inVal, &outVal
										*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
										for key, val := range *in {
											var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
											if val == nil {
												(*out)[key] = nil
											} else {
												inVal := (*in)[key]
												in, out := &inVal, &outVal
												*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
												for key, val := range *in {
													var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
													if val == nil {
														(*out)[key] = nil
													} else {
														inVal := (*in)[key]
														in, out := &inVal, &outVal
														*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
														for key, val := range *in {
															var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
															if val == nil {
																(*out)[key] = nil
															} else {
																inVal := (*in)[key]
																in, out := &inVal, &outVal
																*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																for key, val := range *in {
																	var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																	if val == nil {
																		(*out)[key] = nil
																	} else {
																		inVal := (*in)[key]
																		in, out := &inVal, &outVal
																		*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																		for key, val := range *in {
																			var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																			if val == nil {
																				(*out)[key] = nil
																			} else {
																				inVal := (*in)[key]
																				in, out := &inVal, &outVal
																				*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																				for key, val := range *in {
																					var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																					if val == nil {
																						(*out)[key] = nil
																					} else {
																						inVal := (*in)[key]
																						in, out := &inVal, &outVal
																						*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																						for key, val := range *in {
																							var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																							if val == nil {
																								(*out)[key] = nil
																							} else {
																								inVal := (*in)[key]
																								in, out := &inVal, &outVal
																								*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																								for key, val := range *in {
																									var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																									if val == nil {
																										(*out)[key] = nil
																									} else {
																										inVal := (*in)[key]
																										in, out := &inVal, &outVal
																										*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																										for key, val := range *in {
																											var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																											if val == nil {
																												(*out)[key] = nil
																											} else {
																												inVal := (*in)[key]
																												in, out := &inVal, &outVal
																												*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																												for key, val := range *in {
																													var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																													if val == nil {
																														(*out)[key] = nil
																													} else {
																														inVal := (*in)[key]
																														in, out := &inVal, &outVal
																														*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																														for key, val := range *in {
																															var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																															if val == nil {
																																(*out)[key] = nil
																															} else {
																																inVal := (*in)[key]
																																in, out := &inVal, &outVal
																																*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																for key, val := range *in {
																																	var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																	if val == nil {
																																		(*out)[key] = nil
																																	} else {
																																		inVal := (*in)[key]
																																		in, out := &inVal, &outVal
																																		*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																		for key, val := range *in {
																																			var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																			if val == nil {
																																				(*out)[key] = nil
																																			} else {
																																				inVal := (*in)[key]
																																				in, out := &inVal, &outVal
																																				*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																				for key, val := range *in {
																																					var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																					if val == nil {
																																						(*out)[key] = nil
																																					} else {
																																						inVal := (*in)[key]
																																						in, out := &inVal, &outVal
																																						*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																						for key, val := range *in {
																																							var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																							if val == nil {
																																								(*out)[key] = nil
																																							} else {
																																								inVal := (*in)[key]
																																								in, out := &inVal, &outVal
																																								*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																								for key, val := range *in {
																																									var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																									if val == nil {
																																										(*out)[key] = nil
																																									} else {
																																										inVal := (*in)[key]
																																										in, out := &inVal, &outVal
																																										*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																										for key, val := range *in {
																																											var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																											if val == nil {
																																												(*out)[key] = nil
																																											} else {
																																												inVal := (*in)[key]
																																												in, out := &inVal, &outVal
																																												*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																												for key, val := range *in {
																																													var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																													if val == nil {
																																														(*out)[key] = nil
																																													} else {
																																														inVal := (*in)[key]
																																														in, out := &inVal, &outVal
																																														*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																														for key, val := range *in {
																																															var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																															if val == nil {
																																																(*out)[key] = nil
																																															} else {
																																																inVal := (*in)[key]
																																																in, out := &inVal, &outVal
																																																*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																for key, val := range *in {
																																																	var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																	if val == nil {
																																																		(*out)[key] = nil
																																																	} else {
																																																		inVal := (*in)[key]
																																																		in, out := &inVal, &outVal
																																																		*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																		for key, val := range *in {
																																																			var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																			if val == nil {
																																																				(*out)[key] = nil
																																																			} else {
																																																				inVal := (*in)[key]
																																																				in, out := &inVal, &outVal
																																																				*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																				for key, val := range *in {
																																																					var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																					if val == nil {
																																																						(*out)[key] = nil
																																																					} else {
																																																						inVal := (*in)[key]
																																																						in, out := &inVal, &outVal
																																																						*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																						for key, val := range *in {
																																																							var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																							if val == nil {
																																																								(*out)[key] = nil
																																																							} else {
																																																								inVal := (*in)[key]
																																																								in, out := &inVal, &outVal
																																																								*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																								for key, val := range *in {
																																																									var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																									if val == nil {
																																																										(*out)[key] = nil
																																																									} else {
																																																										inVal := (*in)[key]
																																																										in, out := &inVal, &outVal
																																																										*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																										for key, val := range *in {
																																																											var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																											if val == nil {
																																																												(*out)[key] = nil
																																																											} else {
																																																												inVal := (*in)[key]
																																																												in, out := &inVal, &outVal
																																																												*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																												for key, val := range *in {
																																																													var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																													if val == nil {
																																																														(*out)[key] = nil
																																																													} else {
																																																														inVal := (*in)[key]
																																																														in, out := &inVal, &outVal
																																																														*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																														for key, val := range *in {
																																																															var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																															if val == nil {
																																																																(*out)[key] = nil
																																																															} else {
																																																																inVal := (*in)[key]
																																																																in, out := &inVal, &outVal
																																																																*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																for key, val := range *in {
																																																																	var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																																	if val == nil {
																																																																		(*out)[key] = nil
																																																																	} else {
																																																																		inVal := (*in)[key]
																																																																		in, out := &inVal, &outVal
																																																																		*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																		for key, val := range *in {
																																																																			var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																																			if val == nil {
																																																																				(*out)[key] = nil
																																																																			} else {
																																																																				inVal := (*in)[key]
																																																																				in, out := &inVal, &outVal
																																																																				*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																				for key, val := range *in {
																																																																					var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																																					if val == nil {
																																																																						(*out)[key] = nil
																																																																					} else {
																																																																						inVal := (*in)[key]
																																																																						in, out := &inVal, &outVal
																																																																						*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																						for key, val := range *in {
																																																																							var outVal map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																																							if val == nil {
																																																																								(*out)[key] = nil
																																																																							} else {
																																																																								inVal := (*in)[key]
																																																																								in, out := &inVal, &outVal
																																																																								*out = make(map[string]map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																								for key, val := range *in {
																																																																									var outVal map[string]map[string]map[string]map[string]map[string]map[string]int32
																																																																									if val == nil {
																																																																										(*out)[key] = nil
																																																																									} else {
																																																																										inVal := (*in)[key]
																																																																										in, out := &inVal, &outVal
																																																																										*out = make(map[string]map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																										for key, val := range *in {
																																																																											var outVal map[string]map[string]map[string]map[string]map[string]int32
																																																																											if val == nil {
																																																																												(*out)[key] = nil
																																																																											} else {
																																																																												inVal := (*in)[key]
																																																																												in, out := &inVal, &outVal
																																																																												*out = make(map[string]map[string]map[string]map[string]map[string]int32, len(*in))
																																																																												for key, val := range *in {
																																																																													var outVal map[string]map[string]map[string]map[string]int32
																																																																													if val == nil {
																																																																														(*out)[key] = nil
																																																																													} else {
																																																																														inVal := (*in)[key]
																																																																														in, out := &inVal, &outVal
																																																																														*out = make(map[string]map[string]map[string]map[string]int32, len(*in))
																																																																														for key, val := range *in {
																																																																															var outVal map[string]map[string]map[string]int32
																																																																															if val == nil {
																																																																																(*out)[key] = nil
																																																																															} else {
																																																																																inVal := (*in)[key]
																																																																																in, out := &inVal, &outVal
																																																																																*out = make(map[string]map[string]map[string]int32, len(*in))
																																																																																for key, val := range *in {
																																																																																	var outVal map[string]map[string]int32
																																																																																	if val == nil {
																																																																																		(*out)[key] = nil
																																																																																	} else {
																																																																																		inVal := (*in)[key]
																																																																																		in, out := &inVal, &outVal
																																																																																		*out = make(map[string]map[string]int32, len(*in))
																																																																																		for key, val := range *in {
																																																																																			var outVal map[string]int32
																																																																																			if val == nil {
																																																																																				(*out)[key] = nil
																																																																																			} else {
																																																																																				inVal := (*in)[key]
																																																																																				in, out := &inVal, &outVal
																																																																																				*out = make(map[string]int32, len(*in))
																																																																																				for key, val := range *in {
																																																																																					(*out)[key] = val
																																																																																				}
																																																																																			}
																																																																																			(*out)[key] = outVal
																																																																																		}
																																																																																	}
																																																																																	(*out)[key] = outVal
																																																																																}
																																																																															}
																																																																															(*out)[key] = outVal
																																																																														}
																																																																													}
																																																																													(*out)[key] = outVal
																																																																												}
																																																																											}
																																																																											(*out)[key] = outVal
																																																																										}
																																																																									}
																																																																									(*out)[key] = outVal
																																																																								}
																																																																							}
																																																																							(*out)[key] = outVal
																																																																						}
																																																																					}
																																																																					(*out)[key] = outVal
																																																																				}
																																																																			}
																																																																			(*out)[key] = outVal
																																																																		}
																																																																	}
																																																																	(*out)[key] = outVal
																																																																}
																																																															}
																																																															(*out)[key] = outVal
																																																														}
																																																													}
																																																													(*out)[key] = outVal
																																																												}
																																																											}
																																																											(*out)[key] = outVal
																																																										}
																																																									}
																																																									(*out)[key] = outVal
																																																								}
																																																							}
																																																							(*out)[key] = outVal
																																																						}
																																																					}
																																																					(*out)[key] = outVal
																																																				}
																																																			}
																																																			(*out)[key] = outVal
																																																		}
																																																	}
																																																	(*out)[key] = outVal
																																																}
																																															}
																																															(*out)[key] = outVal
																																														}
																																													}
																																													(*out)[key] = outVal
																																												}
																																											}
																																											(*out)[key] = outVal
																																										}
																																									}
																																									(*out)[key] = outVal
																																								}
																																							}
																																							(*out)[key] = outVal
																																						}
																																					}
																																					(*out)[key] = outVal
																																				}
																																			}
																																			(*out)[key] = outVal
																																		}
																																	}
																																	(*out)[key] = outVal
																																}
																															}
																															(*out)[key] = outVal
																														}
																													}
																													(*out)[key] = outVal
																												}
																											}
																											(*out)[key] = outVal
																										}
																									}
																									(*out)[key] = outVal
																								}
																							}
																							(*out)[key] = outVal
																						}
																					}
																					(*out)[key] = outVal
																				}
																			}
																			(*out)[key] = outVal
																		}
																	}
																	(*out)[key] = outVal
																}
															}
															(*out)[key] = outVal
														}
													}
													(*out)[key] = outVal
												}
											}
											(*out)[key] = outVal
										}
									}
									(*out)[key] = outVal
								}
							}
							(*out)[key] = outVal
						}
					}
					(*out)[key] = outVal
				}
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestKindSpec.
func (in *TestKindSpec) DeepCopy() *TestKindSpec {
	if in == nil {
		return nil
	}
	out := new(TestKindSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TestKindStatus) DeepCopyInto(out *TestKindStatus) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TestKindStatus.
func (in *TestKindStatus) DeepCopy() *TestKindStatus {
	if in == nil {
		return nil
	}
	out := new(TestKindStatus)
	in.DeepCopyInto(out)
	return out
}
